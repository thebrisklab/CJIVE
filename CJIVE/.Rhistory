i.JX2.hat = jive.unknown.perm$joint[[2]]
i.JntBlock = rbind(i.JX1.hat, i.JX2.hat)
i.JntScores.hat= svd(i.JntBlock, nu = i.rJ, nv = i.rJ)[['v']]
if(i.rJ == 0){
i.JntScores.hat = rep(0,n)
i.JX1.hat = matrix(0, nrow = n, ncol = p1)
i.JX2.hat = matrix(0, nrow = n, ncol = p2)
i.jnt.subnorm = chord.norm.diff(JntScores, i.JntScores.hat)
i.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, t(i.JX1.hat))
i.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, t(i.JX2.hat))
} else {
i.JX1.hat = jive.unknown.perm$joint[[1]]
i.JX2.hat = jive.unknown.perm$joint[[2]]
i.jnt.loadX = svd(i.JX1.hat, nu = i.rJ, nv = i.rJ)[['u']]
i.jnt.loadY = svd(i.JX2.hat, nu = i.rJ, nv = i.rJ)[['u']]
i.jnt.subnorm = chord.norm.diff(JntScores, i.JntScores.hat)
i.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, i.jnt.loadX)
i.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, i.jnt.loadY)
}
i.IX1.hat = jive.unknown.perm$individual[[1]]
i.IX2.hat = jive.unknown.perm$individual[[2]]
i.IX1.svd = svd(i.IX1.hat, nu = i.rI[1], nv = i.rI[1])
i.IX2.svd = svd(i.IX2.hat, nu = i.rI[2], nv = i.rI[2])
i.bX1.hat = i.IX1.svd[['v']]; i.bX2.hat = i.IX2.svd[['v']]
i.W.IX1.hat = i.IX1.svd[['u']]; i.W.IX2.hat = i.IX2.svd[['u']]
if(i.rI[1] == 0){
i.indiv.X1.subnorm = i.indiv.X1.loadnorm = 1
} else {
i.indiv.X1.subnorm = chord.norm.diff(IndivScore.X1, i.bX1.hat)
i.indiv.X1.loadnorm = chord.norm.diff(IndivLd.X1, i.W.IX1.hat)
}
if(i.rI[2] == 0){
i.indiv.X2.subnorm = i.indiv.X2.loadnorm = 1
} else {
i.indiv.X2.subnorm = chord.norm.diff(IndivScore.X2, i.bX2.hat)
i.indiv.X2.loadnorm = chord.norm.diff(IndivLd.X2, i.W.IX2.hat)
}
#####Retrieve restuls from R.JIVE package with ranks not specified: use permutation method to find them
i.c.rJ = jive.oracle.perm[["rankJ"]]
i.c.rI = jive.oracle.perm[["rankA"]]
i.c.JX1.hat = jive.oracle.perm$joint[[1]]
i.c.JX2.hat = jive.oracle.perm$joint[[2]]
i.c.JntBlock = rbind(i.c.JX1.hat, i.c.JX2.hat)
i.c.JntScores.hat= svd(i.c.JntBlock, nu = i.c.rJ, nv = i.c.rJ)[['v']]
if(i.c.rJ == 0){
i.c.JntScores.hat = rep(0,n)
i.c.JX1.hat = matrix(0, nrow = n, ncol = p1)
i.c.JX2.hat = matrix(0, nrow = n, ncol = p2)
i.c.jnt.subnorm = chord.norm.diff(JntScores, i.c.JntScores.hat)
i.c.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, t(i.c.JX1.hat))
i.c.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, t(i.c.JX2.hat))
} else {
i.c.JX1.hat = jive.oracle.perm$joint[[1]]
i.c.JX2.hat = jive.oracle.perm$joint[[2]]
i.c.jnt.loadX = svd(i.c.JX1.hat, nu = i.c.rJ, nv = i.c.rJ)[['u']]
i.c.jnt.loadY = svd(i.c.JX2.hat, nu = i.c.rJ, nv = i.c.rJ)[['u']]
i.c.jnt.subnorm = chord.norm.diff(JntScores, i.c.JntScores.hat)
i.c.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, i.c.jnt.loadX)
i.c.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, i.c.jnt.loadY)
}
i.c.IX1.hat = jive.oracle.perm$individual[[1]]
i.c.IX2.hat = jive.oracle.perm$individual[[2]]
i.c.IX1.svd = svd(i.c.IX1.hat, nu = i.c.rI[1], nv = i.c.rI[1])
i.c.IX2.svd = svd(i.c.IX2.hat, nu = i.c.rI[2], nv = i.c.rI[2])
i.c.bX1.hat = i.c.IX1.svd[['v']]; i.c.bX2.hat = i.c.IX2.svd[['v']]
i.c.W.IX1.hat = i.c.IX1.svd[['u']]; i.c.W.IX2.hat = i.c.IX2.svd[['u']]
i.c.indiv.X1.subnorm = chord.norm.diff(IndivScore.X1, i.c.bX1.hat)
i.c.indiv.X2.subnorm = chord.norm.diff(IndivScore.X2, i.c.bX2.hat)
i.c.indiv.X1.loadnorm = chord.norm.diff(IndivLd.X1, i.c.W.IX1.hat)
i.c.indiv.X2.loadnorm = chord.norm.diff(IndivLd.X2, i.c.W.IX2.hat)
####Retrieve results from aJIVE package with oracle ranks specified
a.rJ.c = ajive.oracle$joint_rank
a.rI.c1 = ajive.oracle$block_decomps[[1]]$individual$rank
a.rI.c2 = ajive.oracle$block_decomps[[2]]$individual$rank
a.c.JntScores.hat = ajive.oracle$joint_scores
if(a.rJ.c == 0){
a.c.JntScores.hat = rep(0,n)
a.c.JX1.hat = matrix(0, nrow = n, ncol = p1)
a.c.JX2.hat = matrix(0, nrow = n, ncol = p2)
a.c.jnt.subnorm = chord.norm.diff(JntScores, a.c.JntScores.hat)
a.c.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, t(a.c.JX1.hat))
a.c.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, t(a.c.JX2.hat))
} else {
a.c.jnt.loadX = ajive.oracle$block_decomps[[1]]$joint$v
a.c.jnt.loadY = ajive.oracle$block_decomps[[2]]$joint$v
a.c.jnt.subnorm = chord.norm.diff(JntScores, a.c.JntScores.hat)
a.c.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, a.c.jnt.loadX)
a.c.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, a.c.jnt.loadY)
}
a.c.W.IX2.hat = ajive.oracle$block_decomps[[2]][["individual"]][["v"]]
a.c.W.IX1.hat = ajive.oracle$block_decomps[[1]][["individual"]][["v"]]
a.c.bX1.hat = ajive.oracle$block_decomps[[1]][["individual"]][["u"]]
a.c.bX2.hat = ajive.oracle$block_decomps[[2]][["individual"]][["u"]]
a.c.indiv.X1.subnorm = chord.norm.diff(IndivScore.X1, a.c.bX1.hat)
a.c.indiv.X2.subnorm = chord.norm.diff(IndivScore.X2, a.c.bX2.hat)
a.c.indiv.X1.loadnorm = chord.norm.diff(IndivLd.X1, a.c.W.IX1.hat)
a.c.indiv.X2.loadnorm = chord.norm.diff(IndivLd.X2, a.c.W.IX2.hat)
### Apply aJIVE method with ranks not specified: use BIC method to find them
a.rJ.w = ajive.over$joint_rank
a.rI.w1 = ajive.over$block_decomps[[1]]$individual$rank
a.rI.w2 = ajive.over$block_decomps[[2]]$individual$rank
a.w.JntScores.hat = ajive.over$joint_scores
if(a.rJ.w == 0){
a.w.JntScores.hat = rep(0,n)
a.w.JX1.hat = matrix(0, nrow = n, ncol = p1)
a.w.JX2.hat = matrix(0, nrow = n, ncol = p2)
a.w.jnt.subnorm = chord.norm.diff(JntScores, a.w.JntScores.hat)
a.w.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, t(a.w.JX1.hat))
a.w.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, t(a.w.JX2.hat))
} else {
a.w.jnt.loadX = ajive.over$block_decomps[[1]]$joint$v
a.w.jnt.loadY = ajive.over$block_decomps[[2]]$joint$v
a.w.jnt.subnorm = chord.norm.diff(JntScores, a.w.JntScores.hat)
a.w.jnt.loadX1.norm = chord.norm.diff(JntLd.X1, a.w.jnt.loadX)
a.w.jnt.loadX2.norm = chord.norm.diff(JntLd.X2, a.w.jnt.loadY)
}
a.w.W.IX2.hat = ajive.over$block_decomps[[2]][["individual"]][["v"]]
a.w.W.IX1.hat = ajive.over$block_decomps[[1]][["individual"]][["v"]]
a.w.bX1.hat = ajive.over$block_decomps[[1]][["individual"]][["u"]]
a.w.bX2.hat = ajive.over$block_decomps[[2]][["individual"]][["u"]]
a.w.indiv.X1.subnorm = chord.norm.diff(IndivScore.X1, a.w.bX1.hat)
a.w.indiv.X2.subnorm = chord.norm.diff(IndivScore.X2, a.w.bX2.hat)
a.w.indiv.X1.loadnorm = chord.norm.diff(IndivLd.X1, a.w.W.IX1.hat)
a.w.indiv.X2.loadnorm = chord.norm.diff(IndivLd.X2, a.w.W.IX2.hat)
###Predictions
#CJIVE
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
# cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
# cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
joint.rank = r.J, cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, JntScores[-rnd.smp,]))
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, JntScores[-rnd.smp,]))
PredEvals = c(cc.pred.cor, a.c.pred.cor, r.pred.cor)
# cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, JntScores[-rnd.smp,]))
#AJIVE
AJIVE.res.sub1 = ajive(blocks.sub1, true_signal_ranks, joint_rank = r.J)
a.jnt_score.sub1 = AJIVE.res.sub1$joint_scores
AJIVE.res.sub2 = ajive(blocks.sub2, true_signal_ranks, joint_rank = r.J)
a.jnt_score.sub2 = AJIVE.res.sub2$joint_scores
JL.1_sub1 = t(AJIVE.res.sub1$block_decomps[[1]]$joint$full)%*%a.jnt_score.sub1
JL.2_sub1 = t(AJIVE.res.sub1$block_decomps[[2]]$joint$full)%*%a.jnt_score.sub1
JL.1_sub1.ginv = ginv(JL.1_sub1)
JL.2_sub1.ginv = ginv(JL.2_sub1)
# a.pred.aJIVE.sub2 = (blocks.sub2[[1]]%*%JL.1_sub1 + blocks.sub2[[2]]%*%JL.2_sub1)/2
a.pred.aJIVE.sub2 = (blocks.sub2[[1]]%*%t(JL.1_sub1.ginv) + blocks.sub2[[2]]%*%t(JL.2_sub1.ginv))/2
# a.c.pred.cor = diag(cor(a.jnt_score.sub2, a.pred.aJIVE.sub2))
a.c.pred.cor = diag(cor(a.pred.aJIVE.sub2, JntScores[-rnd.smp,]))
#R.JIVE
t.blocks.sub1 = lapply(blocks.sub1, t)
t.blocks.sub2 = lapply(blocks.sub2, t)
r.jive.res_sub1 = jive(t.blocks.sub1,rankJ = r.J, rankA = c(r.I1, r.I2), method = "given")
r.pred.res = jive.predict(data.new = t.blocks.sub2, jive.output = r.jive.res_sub1)
r.pred.aJIVE.sub2 = r.pred.res$joint.scores
r.pred.cor = diag(cor(t(r.pred.aJIVE.sub2), JntScores[-rnd.smp,]))
PredEvals = c(cc.pred.cor, a.c.pred.cor, r.pred.cor)
devtools::load_all(".")
library(CJIVE)
library(CJIVE)
library(CJIVE)
?gg.norm.plot
library(CJIVE)
library(CJIVE)
library(CJIVE)
library(CJIVE)
devtools::load_all(".")
library(CJIVE)
library(CJIVE)
library(CJIVE)
library(CJIVE)
n = 400 #sample size
p1 = 2000 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
JntScores = ToyDat[['Scores']][['Joint']]
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
library(CJIVE)
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
?cc.jive.pred
cc.jive.pred
cc.pred.jnt.scores.sub2 = CJIVE::cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
library(CJIVE)
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
library(CJIVE)
n = 400 #sample size
p1 = 2000 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
JntScores = ToyDat[['Scores']][['Joint']]
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = r.J+c(r.I1,r.I2),
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = r.J+c(r.I1,r.I2),
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
cc.pred.cor
plot(cor(cc.pred.jnt.scores.sub2, JntScores[-rnd.smp,]))
plot(cc.pred.jnt.scores.sub2, JntScores[-rnd.smp,])
plot(cc.pred.jnt.scores.sub2, JntScores.2)
plot(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2)
n = 400 #sample size
p1 = 2000 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
# Split data randomly into two subsamples
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
# Joint scores for the two sub samples
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
# Conduct CJIVE analysis on the first sub-sample and store the canonical loadings and canonical correlations
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
# Conduct CJIVE analysis on the second sub-sample. We will predict these joint scores using the results above
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# Calculate the Pearson correlation coefficient between predicted and calculated joint scores for sub-sample 2
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal norm
layout(matrix(1:2, ncol = 2))
plot(cc.pred.jnt.scores.sub2, JntScores.2, xlab = "Predicted Joint Scores", ylab = "True Joint Scores")
plot(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2, xlab = "Predicted Joint Scores", ylab = "Estimated Joint Scores")
layout(1)
# Conduct CJIVE analysis on the second sub-sample. We will predict these joint scores using the results above
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = r.J+c(r.I1,r.I2),
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# Calculate the Pearson correlation coefficient between predicted and calculated joint scores for sub-sample 2
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal norm
layout(matrix(1:2, ncol = 2))
plot(cc.pred.jnt.scores.sub2, JntScores.2, xlab = "Predicted Joint Scores", ylab = "True Joint Scores")
plot(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2, xlab = "Predicted Joint Scores", ylab = "Estimated Joint Scores")
layout(1)
n = 400 #sample size
p1 = 2000 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
# Split data randomly into two subsamples
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
# Joint scores for the two sub samples
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
# Conduct CJIVE analysis on the first sub-sample and store the canonical loadings and canonical correlations
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
# Conduct CJIVE analysis on the second sub-sample. We will predict these joint scores using the results above
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# Calculate the Pearson correlation coefficient between predicted and calculated joint scores for sub-sample 2
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal norm
layout(matrix(1:2, ncol = 2))
plot(cc.pred.jnt.scores.sub2, JntScores.2, xlab = "Predicted Joint Scores", ylab = "True Joint Scores")
plot(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2, xlab = "Predicted Joint Scores", ylab = "Estimated Joint Scores")
layout(1)
n = 200 #sample size
p1 = 2000 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
# Split data randomly into two subsamples
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
# Joint scores for the two sub samples
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
# Conduct CJIVE analysis on the first sub-sample and store the canonical loadings and canonical correlations
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
# Conduct CJIVE analysis on the second sub-sample. We will predict these joint scores using the results above
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# Calculate the Pearson correlation coefficient between predicted and calculated joint scores for sub-sample 2
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal norm
layout(matrix(1:2, ncol = 2))
plot(cc.pred.jnt.scores.sub2, JntScores.2, xlab = "Predicted Joint Scores", ylab = "True Joint Scores")
plot(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2, xlab = "Predicted Joint Scores", ylab = "Estimated Joint Scores")
layout(1)
n = 200 #sample size
p1 = 2000 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
# Split data randomly into two subsamples
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
# Joint scores for the two sub samples
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
# Conduct CJIVE analysis on the first sub-sample and store the canonical loadings and canonical correlations
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
# Conduct CJIVE analysis on the second sub-sample. We will predict these joint scores using the results above
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# Calculate the Pearson correlation coefficient between predicted and calculated joint scores for sub-sample 2
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal norm
layout(matrix(1:2, ncol = 2))
plot(cc.pred.jnt.scores.sub2, JntScores.2, xlab = "Predicted Joint Scores", ylab = "True Joint Scores")
plot(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2, xlab = "Predicted Joint Scores", ylab = "Estimated Joint Scores")
layout(1)
library(CJIVE)
n = 200 #sample size
p1 = 2000 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
# Split data randomly into two subsamples
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
# Joint scores for the two sub samples
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
# Conduct CJIVE analysis on the first sub-sample and store the canonical loadings and canonical correlations
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = r.J+c(r.I1,r.I2), center = F, perm.test = F, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
# Conduct CJIVE analysis on the second sub-sample. We will predict these joint scores using the results above
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = F, perm.test = F, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2, signal.ranks = true_signal_ranks,
cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# Calculate the Pearson correlation coefficient between predicted and calculated joint scores for sub-sample 2
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal norm
layout(matrix(1:2, ncol = 2))
plot(cc.pred.jnt.scores.sub2, JntScores.2, xlab = "Predicted Joint Scores", ylab = "True Joint Scores")
plot(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2, xlab = "Predicted Joint Scores", ylab = "Estimated Joint Scores")
layout(1)
n = 200 #sample size
p1 = 200 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
n = 200 #sample size
p1 = 200 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
library(CJIVE)
n = 200 #sample size
p1 = 200 #Number of features in data set X1
p2 = 1000 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
p2 = 200 #Number of features in data set X2
r.J = 3 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenToyDatBinRank(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks <- ToyDat$'Data Blocks'
temp.svd.1 = svd(blocks[[1]])
plot(temp.svd.1$d^2)
